<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predictive Coding — How the Brain Learns</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=DM+Sans:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@300;400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'DM Sans', sans-serif;
            background: #2b2e4a;
            overflow: hidden;
            color: #e8e6e3
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }

        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 250;
            background: radial-gradient(ellipse at center, transparent 70%, rgba(0, 0, 0, 0.04) 85%, rgba(0, 0, 0, 0.12) 100%);
        }

        .film-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 260;
            opacity: 0.025;
            mix-blend-mode: overlay;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }

        .letterbox-top,
        .letterbox-bottom {
            position: fixed;
            left: 0;
            right: 0;
            height: 42px;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(12px);
            z-index: 400
        }

        .letterbox-top {
            top: 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06)
        }

        .letterbox-bottom {
            bottom: 0;
            border-top: 1px solid rgba(0, 0, 0, 0.06)
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 300
        }

        .header-bar {
            position: absolute;
            top: 25px;
            left: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100
        }

        .cinematic-script-overlay {
            position: fixed;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 920px;
            text-align: center;
            z-index: 500;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.8s ease
        }

        .script-text {
            font-family: 'DM Sans', sans-serif;
            font-size: 1.5em;
            color: #fff;
            font-weight: 500;
            line-height: 1.4;
            text-shadow: 0 2px 12px rgba(0, 0, 0, 0.7), 0 0 40px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1)
        }

        .script-text.active {
            opacity: 1;
            transform: translateY(0)
        }

        .script-text strong {
            color: #a78bfa;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(167, 139, 250, 0.6), 0 1px 3px rgba(0, 0, 0, 0.6)
        }

        .script-sub {
            display: none;
        }

        .network-logo {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 700;
            font-size: 0.9em;
            letter-spacing: 6px;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5)
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: #a78bfa;
            border-radius: 50%;
            box-shadow: 0 0 12px rgba(167, 139, 250, 0.8);
            animation: livePulse 2s ease-in-out infinite
        }

        @keyframes livePulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1)
            }

            50% {
                opacity: 0.3;
                transform: scale(1.3)
            }
        }

        .title-section {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 440px;
            text-align: center;
            border-left: none;
            padding-left: 0;
            transition: opacity 1s ease
        }

        .series-tag {
            display: none;
        }

        .main-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.8em, 3.5vw, 2.8em);
            font-weight: 600;
            color: #fff;
            line-height: 0.95;
            margin-bottom: 6px;
            letter-spacing: -0.04em;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4)
        }

        .main-subtitle {
            font-size: 0.85em;
            font-weight: 500;
            color: #d0cfc8;
            line-height: 1.3;
            margin: 0 auto 12px auto;
            max-width: 100%;
        }

        .year-badge {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding: 0 0 4px 0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65em;
            color: #b0b0b0
        }

        .year-badge span {
            color: #a78bfa;
            font-weight: 700
        }

        .equation-panel {
            display: none !important;
        }

        .eq-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.55em;
            font-weight: 700;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: #64748b;
            margin-bottom: 12px
        }

        .eq-math {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85em;
            color: #0f172a;
            line-height: 1.8;
            font-weight: 600;
            text-shadow: none
        }

        .footer-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(43, 46, 74, 0.95);
            backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 42px;
            z-index: 500
        }

        .footer-left {
            display: flex;
            align-items: center;
            gap: 20px
        }

        .footer-icon {
            width: 26px;
            height: 26px;
            background: #a78bfa;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cormorant Garamond', serif;
            font-weight: 700;
            font-size: 0.9em;
            color: #0a0814
        }

        .footer-url {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.72em;
            font-weight: 700;
            color: #fff;
            letter-spacing: 1.5px
        }

        .footer-right {
            text-align: right;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px
        }

        .footer-name {
            font-size: 0.75em;
            font-weight: 700;
            color: #fff
        }

        .footer-cred {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.52em;
            color: #a78bfa;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.8px
        }

        /* Intro card */
        .intro-card-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-bottom: 0;
            opacity: 1;
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2000;
            text-align: center
        }

        .intro-card-overlay.fade-out {
            opacity: 0;
            pointer-events: none
        }

        .intro-pre-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75em;
            font-weight: 600;
            letter-spacing: 6px;
            text-transform: uppercase;
            color: #d1d5db;
            opacity: 0;
            transform: translateY(10px);
            animation: introFadeUp 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.05s forwards;
            transition: all 0.3s ease
        }

        .intro-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(3.0em, 12vw, 4.5em);
            font-weight: 600;
            color: #fff;
            margin: 10px 0 0 0;
            letter-spacing: -2px;
            line-height: 0.85;
            opacity: 0;
            transform: translateY(25px);
            animation: introTitleReveal 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.15s forwards;
            transition: all 0.3s ease;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5)
        }

        .intro-accent-line {
            width: 60px;
            height: 4px;
            background: linear-gradient(90deg, #a78bfa, #06b6d4);
            margin-top: 20px;
            transform: scaleX(0);
            animation: introLineExpand 0.3s cubic-bezier(0.16, 1, 0.3, 1) 0.35s forwards;
            transition: transform 0.25s ease;
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.5)
        }

        @keyframes introFadeUp {
            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        @keyframes introTitleReveal {
            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        @keyframes introLineExpand {
            to {
                transform: scaleX(1)
            }
        }

        /* End card */
        .end-card-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
            z-index: 1000;
            text-align: center
        }

        .end-card-overlay.active {
            opacity: 1;
            pointer-events: auto
        }

        .credits-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 4em;
            font-weight: 400;
            color: #0f172a;
            margin-bottom: 20px
        }

        .credits-subtitle {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8em;
            letter-spacing: 5px;
            text-transform: uppercase;
            color: #475569;
            margin-bottom: 40px
        }

        .credits-name {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5em;
            font-weight: 600;
            color: #0f172a
        }

        .credits-link {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7em;
            margin-top: 30px;
            color: #999;
            text-decoration: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            transition: all 0.3s
        }

        .credits-link:hover {
            color: #a78bfa;
            border-bottom-color: #a78bfa
        }

        /* VFX HUD */
        .vfx-progress {
            position: fixed;
            bottom: 60px;
            left: 0;
            right: 0;
            height: 2px;
            z-index: 450;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.04)
        }

        .vfx-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #a78bfa, #06b6d4);
            box-shadow: 0 0 8px rgba(167, 139, 250, 0.5), 0 0 20px rgba(6, 182, 212, 0.3);
            transition: width 0.15s linear
        }

        .corner-mark {
            position: fixed;
            width: 24px;
            height: 24px;
            z-index: 450;
            pointer-events: none;
            opacity: 0.3;
            animation: cornerPulse 4s ease-in-out infinite
        }

        .corner-mark.tl {
            top: 48px;
            left: 10px;
            border-top: 1.5px solid #a78bfa;
            border-left: 1.5px solid #a78bfa
        }

        .corner-mark.tr {
            top: 48px;
            right: 10px;
            border-top: 1.5px solid #a78bfa;
            border-right: 1.5px solid #a78bfa
        }

        .corner-mark.bl {
            bottom: 66px;
            left: 10px;
            border-bottom: 1.5px solid #a78bfa;
            border-left: 1.5px solid #a78bfa
        }

        .corner-mark.br {
            bottom: 66px;
            right: 10px;
            border-bottom: 1.5px solid #a78bfa;
            border-right: 1.5px solid #a78bfa
        }

        @keyframes cornerPulse {

            0%,
            100% {
                opacity: 0.25
            }

            50% {
                opacity: 0.5
            }
        }

        .data-hud {
            display: none;
        }

        .section-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #fff;
            z-index: 2500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.06s ease-out
        }

        .anamorphic-streak {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            z-index: 265;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
            background: linear-gradient(90deg, transparent 5%, rgba(167, 139, 250, 0.0) 15%, rgba(167, 139, 250, 0.12) 35%, rgba(100, 180, 255, 0.2) 50%, rgba(167, 139, 250, 0.12) 65%, rgba(167, 139, 250, 0.0) 85%, transparent 95%);
            filter: blur(1px)
        }

        .scan-lines-ov {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 245;
            opacity: 0.012;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 255, 255, 0.04) 2px, rgba(255, 255, 255, 0.04) 4px)
        }

        .light-leak {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 255;
            opacity: 0;
            background: radial-gradient(ellipse at 20% 50%, rgba(167, 100, 255, 0.10), transparent 60%);
            transition: opacity 3s ease
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="vignette-overlay"></div>
    <div class="film-grain"></div>
    <div class="scan-lines-ov"></div>
    <div class="section-flash" id="sectionFlash"></div>
    <div class="anamorphic-streak" id="anamStreak"></div>
    <div class="light-leak" id="lightLeak"></div>
    <div class="corner-mark tl"></div>
    <div class="corner-mark tr"></div>
    <div class="corner-mark bl"></div>
    <div class="corner-mark br"></div>
    <div class="data-hud left" id="hudLeft">PC_NET v2.0<br>LAYERS: 4<br>ε_TOTAL: 0.000<br>INFERENCE: ACTIVE</div>
    <div class="data-hud right" id="hudRight">PRED_ERR: 0.00<br>WEIGHT_Δ: LOCAL<br>SYNC: ASYNC</div>
    <div class="vfx-progress">
        <div class="vfx-progress-fill" id="progressFill"></div>
    </div>
    <div class="ui-overlay">
        <div class="header-bar">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#a78bfa" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round"
                style="filter: drop-shadow(0 0 10px rgba(167,139,250,0.9));">
                <path
                    d="M9.5 2c-1.38 0-2.5 1.12-2.5 2.5 0 .26.04.5.11.74C5.35 5.56 4 7.12 4 9c0 1.6 1.05 2.95 2.5 3.39v.11a2.5 2.5 0 0 0 2.5 2.5h.07A3.001 3.001 0 0 0 12 18v2h2v-2a3.001 3.001 0 0 0 2.93-3h.07a2.5 2.5 0 0 0 2.5-2.5v-.11C20.95 11.95 22 10.6 22 9c0-1.88-1.35-3.44-3.11-3.76.07-.24.11-.48.11-.74C19 3.12 17.88 2 16.5 2c-.93 0-1.73.53-2.17 1.3-.43-.19-.91-.3-1.42-.3h-1.82c-.51 0-.99.11-1.42.3A2.484 2.484 0 0 0 9.5 2z" />
                <path d="M12 3v16M15 15l2-2M9 15l-2-2M15 9l2 2M9 9l-2 2" />
            </svg>
        </div>
        <div class="title-section">
            <div class="series-tag">Neuroscience × AI</div>
            <div class="main-title" id="archTitle">Predictive Coding</div>
            <div class="main-subtitle" id="archSubtitle">The brain's learning algorithm — predicting the world to
                understand it.</div>
            <div class="year-badge"><span id="archYear">Rao & Ballard, 1999</span></div>
        </div>
        <div class="equation-panel">
            <div class="eq-label" id="eqLabel">Prediction Error</div>
            <div class="eq-math" id="eqMath">ε<sub>i</sub> = x<sub>i</sub> − Wμ<sub>i+1</sub><br>dμ/dt = −ε<sub>i</sub>
                + W<sup>T</sup>ε<sub>i-1</sub></div>
        </div>
        <div class="cinematic-script-overlay">
            <div class="script-sub" id="scriptSub">PHASE I — THE CREDIT ASSIGNMENT PROBLEM</div>
            <div class="script-text" id="scriptText">How does the brain know which connections to change?</div>
        </div>
    </div>
    <div class="intro-card-overlay" id="introCardOverlay">
        <div class="intro-pre-title">Neuroscience × Artificial Intelligence</div>
        <div class="intro-title"><span>Predictive Coding</span></div>
        <div class="intro-accent-line"></div>
    </div>
    <div class="end-card-overlay" id="endCardOverlay">
        <div class="credits-title" style="font-size:3.5em;margin-bottom:8px;">Watch the Full Video</div>
        <div class="credits-subtitle" style="color:#d1d5db;margin-bottom:30px;">Predictive Coding — From First
            Principles
        </div>
        <a href="https://www.youtube.com/@SamarjithbiswasPhD" target="_blank" class="credits-link"
            style="display:inline-flex;align-items:center;gap:10px;font-size:1em;color:#fff;background:rgba(255,0,0,0.85);padding:14px 32px;border:none;font-family:'DM Sans',sans-serif;font-weight:700;letter-spacing:1px;text-decoration:none;transition:all 0.3s;box-shadow:0 0 25px rgba(255,0,0,0.4);">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                <path
                    d="M23.5 6.2c-.3-1-1-1.8-2-2.1C19.6 3.5 12 3.5 12 3.5s-7.6 0-9.5.6c-1 .3-1.7 1.1-2 2.1C0 8.1 0 12 0 12s0 3.9.5 5.8c.3 1 1.8 2 2.1 1.9.6 9.5.6 9.5.6s7.6 0 9.5-.6c1-.3 1.7-1.1 2-2.1.5-1.9.5-5.8.5-5.8s0-3.9-.5-5.8zM9.6 15.6V8.4l6.4 3.6-6.4 3.6z" />
            </svg>
            Visit YouTube Channel
        </a>
        <div style="margin-top:35px;">
            <div class="credits-name" style="font-size:1.6em;color:#ffffff;">Samarjith Biswas, PHD</div>
            <div
                style="font-size:0.85em;color:#ff4d4d;margin-top:8px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;">
                YouTube Search ID: @SamarjithbiswasPhD</div>
            <p style="font-size:0.85em;max-width:450px;color:#e5e7eb;font-style:italic;margin-top:16px;">"The brain
                predicts the world — and learns from its mistakes."</p>
        </div>
        <div style="margin-top:20px;font-family:'IBM Plex Mono';font-size:0.52em;color:#9ca3af;">© 2026 ·
            samarjithbiswas.com</div>
    </div>
    <div class="footer-bar">
        <div class="footer-left">
            <div class="footer-icon">PC</div>
            <div class="footer-url">@SamarjithbiswasPhD</div>
        </div>
        <div class="footer-right">
            <div class="footer-name">Samarjith Biswas, PHD</div>
            <div class="footer-cred">Neuroscience × Machine Learning</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script>
        window.onerror = function (msg, url, line, col, err) {
            let d = document.getElementById('_errBox');
            if (!d) { d = document.createElement('div'); d.id = '_errBox'; d.style.cssText = 'position:fixed;top:50px;left:50%;transform:translateX(-50%);z-index:99999;background:rgba(255,0,0,0.9);color:#fff;padding:12px 20px;font:12px monospace;max-width:80%;border-radius:6px;white-space:pre-wrap;'; document.body.appendChild(d); }
            d.textContent += (d.textContent ? '\n' : '') + msg + ' (line ' + line + ')';
        };

        const PI = Math.PI, TAU = 2 * PI;

        // ═══════════════════════════════════════════
        // CONTENT — Predictive Coding Sections
        // ═══════════════════════════════════════════
        const sections = [
            // 0: Intro
            { name: "", subtitle: "", year: "", equation: "", eqLabel: "", hideScript: true, narratives: [{ title: "", text: "" }] },
            // 1: Credit Assignment Problem
            {
                name: "The Credit Assignment Problem",
                subtitle: "How does a network with millions of parameters know which weights to change — and by how much?",
                year: "Backprop — 1986",
                equation: "∂L/∂w<sub>ij</sub> = δ<sub>j</sub> · x<sub>i</sub><br>w ← w − η · ∂L/∂w",
                eqLabel: "Backpropagation · Chain Rule",
                narratives: [
                    { title: "", text: "Every learning system faces <strong>credit assignment</strong>: which parameters caused the error?" },
                    { title: "", text: "Backprop solves this with the <strong>chain rule of calculus</strong>, propagating gradients backward through every layer." },
                    { title: "", text: "Backprop requires <strong>separate forward and backward passes</strong> — the brain would need to freeze all computation for hundreds of milliseconds..." },
                    { title: "", text: "...We'd experience <strong>brief blackouts</strong> every time we learn something new." },
                    { title: "", text: "Backprop demands a <strong>central controller</strong> synchronising the entire network." },
                    { title: "", text: "But the brain operates as a <strong>massively parallel, locally autonomous</strong> system. No neuron waits for a global signal." }
                ]
            },
            // 2: Predictive Coding Algorithm
            {
                name: "The Predictive Coding Algorithm",
                subtitle: "Each neural layer predicts the activity of the layer below. Learning is the process of reducing prediction error.",
                year: "Rao & Ballard, 1999",
                equation: "ε<sub>i</sub> = x<sub>i</sub> − Wμ<sub>i+1</sub><br>dμ/dt = −ε<sub>i</sub> + W<sup>T</sup>ε<sub>i-1</sub><br>ΔW ∝ ε<sub>i</sub> · f(μ<sub>i+1</sub>)<sup>T</sup>",
                eqLabel: "Predictive Coding · Update Rules",
                narratives: [
                    { title: "", text: "The brain is a <strong>prediction machine</strong>." },
                    { title: "", text: "Higher layers send <strong>top-down predictions</strong> to lower layers. Lower layers send back <strong>prediction errors</strong> — only what was unexpected." },
                    { title: "", text: "Predictive coding is an <strong>energy-based model</strong>. The total energy is the sum of all squared prediction errors across layers." },
                    { title: "", text: "Learning is simply <strong>rolling downhill</strong> on this energy surface." },
                    { title: "", text: "Each neuron balances two drives: <strong>align with the top-down prediction</strong> from the layer above, and <strong>better predict the layer below</strong>." },
                    { title: "", text: "Equilibrium is reached when these forces cancel." }
                ]
            },
            // 3: Error Neurons & Biological Circuitry
            {
                name: "Error Neurons & Biological Circuitry",
                subtitle: "Dedicated error-coding neurons — possibly the superficial pyramidal cells of cortex — explicitly encode prediction errors.",
                year: "Clark, 2013 · Friston, 2018",
                equation: "ε<sub>i</sub> = x<sub>i</sub> − ΣW<sub>ij</sub>μ<sub>j</sub><br>μ̇<sub>i</sub> = −ε<sub>i</sub> + W<sup>T</sup>ε<sub>i-1</sub>",
                eqLabel: "Error Neuron Dynamics",
                narratives: [
                    { title: "", text: "Every layer needs two cell types: <strong>representational neurons</strong> (μ) encoding the current best guess..." },
                    { title: "", text: "...and <strong>error neurons</strong> (ε) encoding the deviation from the prediction. This is where the term 'predictive <em>coding</em>' originates." },
                    { title: "", text: "Error neurons receive <strong>excitatory input</strong> from local representational neurons and <strong>inhibitory input</strong> from predictions arriving from above." },
                    { title: "", text: "This matches observed cortical microcircuit anatomy remarkably well." },
                    { title: "", text: "The weight update rule — <strong>ΔW ∝ εᵢ · μᵢ₊₁</strong> — is a Hebbian rule: 'neurons that fire together wire together'." },
                    { title: "", text: "This is exactly the kind of <strong>local plasticity</strong> observed at biological synapses." }
                ]
            },
            // 4: Predictive Coding vs Backprop
            {
                name: "Predictive Coding vs Backpropagation",
                subtitle: "PC operates with complete local autonomy — no backward pass, no frozen activations, no central controller required.",
                year: "Millidge et al., 2022",
                equation: "Backprop: global, sequential, two-phase<br>PC: local, parallel, continuous<br>PC ≈ Backprop (at convergence)",
                eqLabel: "Algorithmic Comparison",
                narratives: [
                    { title: "", text: "In predictive coding, <strong>each neuron only needs local information</strong>: its own activity, the prediction arriving from above, and the error signals from below." },
                    { title: "", text: "Zero global coordination required." },
                    { title: "", text: "Unlike backprop's strict <strong>forward-then-backward</strong> cycle, PC runs as a <strong>continuous parallel process</strong>." },
                    { title: "", text: "Neurons simultaneously predict, compare, and adapt — just as biological neurons do." },
                    { title: "", text: "PC's local updates naturally <strong>resist catastrophic forgetting</strong> — the tendency of neural networks to overwrite previously learned knowledge." },
                    { title: "", text: "Backprop focuses solely on the current output error; PC preserves <strong>existing knowledge structure</strong>." }
                ]
            },
            // 5: Applications & The Future
            {
                name: "Neuromorphic & Beyond",
                subtitle: "From understanding biological brains to building the next generation of artificial intelligence.",
                year: "Salvatori et al., 2025",
                equation: "Locality → extreme parallelism<br>Local updates → no catastrophic forgetting<br>PC → next-gen neuromorphic AI",
                eqLabel: "Future Directions",
                narratives: [
                    { title: "", text: "Because every weight update uses only <strong>local information</strong>, predictive coding networks can run on massively parallel hardware..." },
                    { title: "", text: "...like neuromorphic chips or analog compute-in-memory — with <strong>100× better energy efficiency</strong> than GPU backprop." },
                    { title: "", text: "PC networks naturally support <strong>both generation and recognition</strong>." },
                    { title: "", text: "Unclamp the output layer → the network synthesises new data. Clamp the input → it classifies. One architecture, <strong>both directions</strong>." },
                    { title: "", text: "Predictive coding stands as a <strong>compelling bridge</strong> between the learning capabilities of biological brains and next-generation AI architectures." },
                    { title: "", text: "The future of AI may be predictive." }
                ]
            },
            // 6: End
            { name: "The Future of Learning", subtitle: "", equation: "", eqLabel: "", hideScript: true, narratives: [{ title: "", text: "" }] }
        ];

        let scene, camera, renderer, group, anims = [];
        let current = 0, currentNarrative = 0;
        let clock = new THREE.Clock();
        let isPlaying = true, narrativeTimer = 0;
        const NARR_DUR = 9;
        let composer, bloomPass, cinematicPass, sectionStartTime = 0;
        let visualState = { mode: 'idle' };

        const camModes = [
            { r: 160, h: 40, s: 0.008, ly: 5, m: 'dolly' },
            { r: 110, h: 20, s: 0.022, ly: 0, m: 'orbit', tilt: 5 },
            { r: 120, h: 30, s: 0.018, ly: 4, m: 'track' },
            { r: 110, h: 42, s: 0.016, ly: -5, m: 'crane' },
            { r: 90, h: 18, s: 0.024, ly: 0, m: 'pushIn' },
            { r: 140, h: 35, s: 0.014, ly: 8, m: 'orbit', tilt: 12 },
            { r: 130, h: 25, s: 0.01, ly: 0, m: 'drift' }
        ];

        let envMap;
        function createEnvMap() {
            const c = document.createElement('canvas'); c.width = 2048; c.height = 1024;
            const ctx = c.getContext('2d');
            const g = ctx.createLinearGradient(0, 0, 0, 1024);
            g.addColorStop(0, '#ffffff'); g.addColorStop(0.25, '#fefdfa'); g.addColorStop(0.5, '#f5efee'); g.addColorStop(1, '#ebe4e0');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 2048, 1024);
            // Reddish/Pinkish key light reflections to keep biological structures rich
            const softbox = ctx.createRadialGradient(1024, 80, 5, 1024, 80, 450);
            softbox.addColorStop(0, 'rgba(255,100,100,0.6)'); softbox.addColorStop(0.3, 'rgba(200,50,80,0.3)');
            softbox.addColorStop(0.7, 'rgba(150,20,50,0.1)'); softbox.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = softbox; ctx.fillRect(0, 0, 2048, 512);

            const tex = new THREE.Texture(c); tex.needsUpdate = true; tex.mapping = THREE.EquirectangularReflectionMapping;
            return tex;
        }

        // ─── Materials ───
        function bioMat(color, opts = {}) { return new THREE.MeshStandardMaterial({ color, roughness: opts.rough || 0.55, metalness: 0.04, envMap, envMapIntensity: 0.06, emissive: opts.emissive || color, emissiveIntensity: opts.eI || 0.18, transparent: opts.transparent || false, opacity: opts.opacity || 1 }); }
        function wetBioMat(color, opts = {}) { return new THREE.MeshStandardMaterial({ color, roughness: opts.rough || 0.5, metalness: 0.04, envMap, envMapIntensity: 0.06, emissive: opts.emissive || color, emissiveIntensity: opts.eI || 0.18, transparent: true, opacity: opts.opacity || 0.6 }); }
        function glowMat(color, opacity = 0.7) { return new THREE.MeshBasicMaterial({ color, transparent: true, opacity, blending: THREE.NormalBlending }); }
        function wireMat(color, opacity = 0.5) { return new THREE.LineBasicMaterial({ color, transparent: true, opacity, blending: THREE.NormalBlending }); }

        // ─── Palette ───
        const PURPLE = 0xa78bfa, CYAN = 0x06b6d4, AMBER = 0xfbbf24, RED = 0xf43f5e;
        const BIO = { soma: 0x9a6050, axon: 0x7a4838, synBouton: 0x8a1810, vesicle: 0x3388bb, spike: 0x00ffcc, membrane: 0x786048 };

        // ─── Helper: create organic neuron soma ───
        function createOrganicSoma(radius, segments = 64, bloodiness = 1.0) {
            const geo = new THREE.SphereGeometry(radius, segments, segments);
            const pos = geo.attributes.position;
            const cols = new Float32Array(pos.count * 3);
            for (let i = 0; i < pos.count; i++) {
                const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
                const n = v.clone().normalize();
                const d1 = Math.sin(v.x * 1.2) * Math.sin(v.y * 1.1) * Math.sin(v.z * 1.4) * 0.6;
                const d2 = Math.sin(v.x * 2.5 + v.y * 2.0) * Math.cos(v.z * 2.2) * 0.3;
                const d3 = Math.sin(v.x * 4.2 + v.z * 3.5 + v.y * 1.0) * 0.18;
                const d4 = Math.sin(v.y * 7 + v.x * 6) * 0.08;
                const d5 = Math.sin(v.x * 14 + v.y * 12) * 0.03;
                const noise = d1 + d2 + d3 + d4 + d5;
                v.addScaledVector(n, noise);
                pos.setXYZ(i, v.x, v.y, v.z);
                const tone = (noise + 1.4) / 2.8;
                const bp = Math.max(0, 0.35 - tone) * 2.5 * bloodiness;
                cols[i * 3] = 0.52 + tone * 0.15 + bp * 0.35;
                cols[i * 3 + 1] = 0.24 + tone * 0.08 - bp * 0.10;
                cols[i * 3 + 2] = 0.18 + tone * 0.05 - bp * 0.08;
            }
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            geo.computeVertexNormals();
            return geo;
        }

        // ─── Helper: create prediction error particle burst ───
        function createErrorBurst(pos, color) {
            const geo = new THREE.BufferGeometry();
            const N = 30; const p = new Float32Array(N * 3); const v = new Float32Array(N * 3);
            for (let i = 0; i < N; i++) { const th = Math.random() * TAU, ph = Math.random() * PI, r = Math.random(); p[i * 3] = pos.x; p[i * 3 + 1] = pos.y; p[i * 3 + 2] = pos.z; v[i * 3] = Math.sin(ph) * Math.cos(th) * r; v[i * 3 + 1] = Math.cos(ph) * r; v[i * 3 + 2] = Math.sin(ph) * Math.sin(th) * r; }
            geo.setAttribute('position', new THREE.BufferAttribute(p, 3));
            const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color, size: 0.5, transparent: true, opacity: 0.8, blending: THREE.NormalBlending, depthWrite: false }));
            pts.name = '_burst'; group.add(pts);
            anims.push({ obj: pts, type: 'burst', vel: v, life: 0, maxLife: 1.5 });
        }

        // ─── Background scattered neurons ───
        function addBackgroundNeurons(count, spread, ySpread) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * TAU, r = spread * 0.4 + Math.random() * spread * 0.6;
                const x = Math.cos(angle) * r, y = (Math.random() - 0.5) * ySpread, z = Math.sin(angle) * r;
                const size = 1.5 + Math.random() * 2.2;
                const geo = createOrganicSoma(size, 32, 0.6);
                const soma = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.58, metalness: 0.04, envMap, envMapIntensity: 0.08, emissive: 0x661810, emissiveIntensity: 0.22, transparent: true, opacity: 0.85 }));
                soma.position.set(x, y, z); soma.name = `bgN_${i}`; group.add(soma);
                anims.push({ obj: soma, type: 'bgNeuronPulse', phase: Math.random() * TAU });
                // Small dendrites
                for (let d = 0; d < 3; d++) {
                    const dir = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize();
                    const len = size * 2.5 + Math.random() * size * 2;
                    const pts = [];
                    for (let s = 0; s <= 8; s++) { const t = s / 8; pts.push(new THREE.Vector3(x + dir.x * t * len + (Math.random() - 0.5) * 0.4, y + dir.y * t * len + (Math.random() - 0.5) * 0.4, z + dir.z * t * len + (Math.random() - 0.5) * 0.4)); }
                    const rad = 0.08 + Math.random() * 0.12;
                    group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 10, rad, 5, false), bioMat(BIO.axon, { rough: 0.55, eI: 0.12, transparent: true, opacity: 0.65 })));
                }
            }
            // Dust particles
            const dGeo = new THREE.BufferGeometry();
            const dCount = 200, dPos = new Float32Array(dCount * 3);
            for (let i = 0; i < dCount; i++) { dPos[i * 3] = (Math.random() - 0.5) * spread * 3; dPos[i * 3 + 1] = (Math.random() - 0.5) * ySpread * 1.5; dPos[i * 3 + 2] = (Math.random() - 0.5) * spread * 3; }
            dGeo.setAttribute('position', new THREE.BufferAttribute(dPos, 3));
            const dust = new THREE.Points(dGeo, new THREE.PointsMaterial({ color: 0x8866aa, size: 0.15, transparent: true, opacity: 0.15, blending: THREE.NormalBlending, depthWrite: false, sizeAttenuation: true }));
            dust.name = '_dust'; scene.add(dust);
        }

        // ─── Setup Lights ───
        function setupLights() {
            scene.add(new THREE.AmbientLight(0xfff5f0, 0.35));
            const key = new THREE.DirectionalLight(0xfff0e8, 1.4); key.position.set(30, 60, 40); key.castShadow = true; key.shadow.mapSize.set(2048, 2048); scene.add(key);
            const fill = new THREE.DirectionalLight(0x88b0ff, 0.65); fill.position.set(-40, 20, -30); scene.add(fill);
            const rim = new THREE.DirectionalLight(0x00f0ff, 0.50); rim.position.set(60, -20, 30); scene.add(rim);
            const under = new THREE.DirectionalLight(0xffaa88, 0.25); under.position.set(0, -40, 0); scene.add(under);
        }

        // ─── Background atmosphere ───
        function createBG() {
            // Bokeh particles
            const bGeo = new THREE.BufferGeometry();
            const bCount = 300, bPos = new Float32Array(bCount * 3);
            for (let i = 0; i < bCount; i++) { bPos[i * 3] = (Math.random() - 0.5) * 400; bPos[i * 3 + 1] = (Math.random() - 0.5) * 200; bPos[i * 3 + 2] = (Math.random() - 0.5) * 400; }
            bGeo.setAttribute('position', new THREE.BufferAttribute(bPos, 3));
            const bokeh = new THREE.Points(bGeo, new THREE.PointsMaterial({ color: 0xa78bfa, size: 0.4, transparent: true, opacity: 0.10, blending: THREE.NormalBlending, depthWrite: false, sizeAttenuation: true }));
            bokeh.name = '_bokeh'; scene.add(bokeh);
            // Fog planes
            for (let i = 0; i < 3; i++) {
                const fp = new THREE.Mesh(new THREE.PlaneGeometry(400, 300), new THREE.MeshBasicMaterial({ color: 0x080614, transparent: true, opacity: 0.02, side: THREE.DoubleSide, depthWrite: false }));
                fp.position.set((Math.random() - 0.5) * 100, 0, (Math.random() - 0.5) * 100); fp.rotation.y = Math.random() * TAU; fp.name = '_fogPlane'; scene.add(fp);
            }
            // Energy rings
            for (let i = 0; i < 3; i++) {
                const er = new THREE.Mesh(new THREE.TorusGeometry(100 + i * 30, 0.5, 4, 80), new THREE.MeshBasicMaterial({ color: 0x6633aa, transparent: true, opacity: 0.03, blending: THREE.NormalBlending }));
                er.rotation.x = PI / 2 + i * 0.3; er.name = '_eRing_' + i; scene.add(er);
            }
            // God rays
            for (let i = 0; i < 4; i++) {
                const gr = new THREE.Mesh(new THREE.PlaneGeometry(10, 200), new THREE.MeshBasicMaterial({ color: 0x8855cc, transparent: true, opacity: 0.015, side: THREE.DoubleSide, depthWrite: false, blending: THREE.NormalBlending }));
                gr.rotation.z = i * (PI / 4); gr.position.set(0, 0, -50); gr.name = '_godRay'; scene.add(gr);
            }
        }

        // ─── Scene Builders ───

        // SECTION 1: Backprop vs Biology — abstract network with frozen phases
        function buildBackprop() {
            const layers = [4, 6, 6, 4]; const lSpacing = 24, nSpacing = 9;
            const nodePositions = [];
            layers.forEach((cnt, li) => {
                const x = (li - (layers.length - 1) / 2) * lSpacing;
                const layerNodes = [];
                for (let ni = 0; ni < cnt; ni++) {
                    const y = (ni - (cnt - 1) / 2) * nSpacing;
                    const geo = createOrganicSoma(3.2, 48, 0.9);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.45, metalness: 0.10, envMap, envMapIntensity: 0.12, emissive: 0x550a28, emissiveIntensity: 0.25 }));
                    mesh.position.set(x, y, 0); mesh.castShadow = true; mesh.name = `bp_${li}_${ni}`; group.add(mesh);
                    // Nucleus
                    const nuc = new THREE.Mesh(new THREE.SphereGeometry(1.3, 16, 16), wetBioMat(0x3a0818, { rough: 0.45, eI: 0.08 }));
                    nuc.position.set(x, y, 0); group.add(nuc);
                    anims.push({ obj: mesh, type: 'bpNeuron', li, ni, phase: Math.random() * TAU });
                    layerNodes.push({ x, y });
                    // Capillaries on surface
                    for (let c = 0; c < 2; c++) {
                        const cp = [], cen = new THREE.Vector3(x, y, 0);
                        const phi0 = Math.random() * PI, th0 = Math.random() * TAU;
                        for (let s = 0; s <= 8; s++) { const tt = s / 8; cp.push(new THREE.Vector3(x + 2.3 * Math.sin(phi0 + tt * 1.2) * Math.cos(th0 + tt * 0.8), y + 2.3 * Math.cos(phi0 + tt * 1.2), 0 + 2.3 * Math.sin(phi0 + tt * 1.2) * Math.sin(th0 + tt * 0.8))); }
                        group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(cp), 8, 0.025, 4, false), new THREE.MeshStandardMaterial({ color: 0x881510, roughness: 0.45, metalness: 0.06, envMap, envMapIntensity: 0.08, emissive: 0x660a0a, emissiveIntensity: 0.25 })));
                    }
                    // Forward connections
                    if (li < layers.length - 1) {
                        const nCnt = layers[li + 1];
                        for (let nj = 0; nj < nCnt; nj++) {
                            if (Math.random() > 0.5) continue;
                            const nx = (li + 1 - (layers.length - 1) / 2) * lSpacing, ny = (nj - (nCnt - 1) / 2) * nSpacing;
                            const pts = [new THREE.Vector3(x, y, 0), new THREE.Vector3((x + nx) / 2, (y + ny) / 2, (Math.random() - 0.5) * 4), new THREE.Vector3(nx, ny, 0)];
                            const curve = new THREE.CatmullRomCurve3(pts);
                            // Forward connection (white-ish)
                            const fwdTube = new THREE.Mesh(new THREE.TubeGeometry(curve, 10, 0.06, 4, false), new THREE.MeshBasicMaterial({ color: 0xddccff, transparent: true, opacity: 0.15, blending: THREE.NormalBlending }));
                            fwdTube.name = `fwd_${li}_${ni}_${nj}`; group.add(fwdTube);
                            // Backward error connection (red, dashed-like — thinner)
                            const bwdTube = new THREE.Mesh(new THREE.TubeGeometry(curve, 10, 0.04, 4, false), new THREE.MeshBasicMaterial({ color: RED, transparent: true, opacity: 0.0, blending: THREE.NormalBlending }));
                            bwdTube.name = `bwd_${li}_${ni}_${nj}`; group.add(bwdTube);
                            // Signal particles on forward path
                            const sig = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), glowMat(0xddccff, 0.9));
                            sig.name = `fsig_${li}_${ni}`; sig.visible = false; group.add(sig);
                            anims.push({ obj: sig, type: 'spikeTravel', curve, offset: Math.random(), speed: 0.10 });
                        }
                    }
                }
                nodePositions.push(layerNodes);
            });
            // "FROZEN" state overlay — ice-blue tinge rings around all neurons during backward pass
            for (let li = 0; li < layers.length; li++) {
                for (let ni = 0; ni < layers[li]; ni++) {
                    const x = (li - (layers.length - 1) / 2) * lSpacing, y = (ni - (layers[li] - 1) / 2) * nSpacing;
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(2.8, 0.12, 8, 32), new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0, blending: THREE.NormalBlending }));
                    ring.position.set(x, y, 0); ring.name = `freeze_${li}_${ni}`; group.add(ring);
                }
            }
            // Error signal particles (backward) - increased density
            for (let i = 0; i < 20; i++) {
                const errSig = new THREE.Mesh(new THREE.SphereGeometry(0.7, 12, 12), glowMat(RED, 0.95));
                errSig.name = `errsig_${i}`; errSig.visible = false; group.add(errSig);
                // Random backward path through layers
                const li = Math.floor(Math.random() * 3);
                const ni = Math.floor(Math.random() * layers[li]);
                const x = (li - (layers.length - 1) / 2) * lSpacing, y = (ni - (layers[li] - 1) / 2) * nSpacing;
                const x2 = ((li + 1) - (layers.length - 1) / 2) * lSpacing, y2 = (Math.random() - 0.5) * nSpacing * (layers[li + 1] || 4);
                const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(x2, y2, 0), new THREE.Vector3((x + x2) / 2, (y + y2) / 2, 0), new THREE.Vector3(x, y, 0)]);
                anims.push({ obj: errSig, type: 'spikeTravel', curve, offset: i / 8, speed: 0.07 });
            }
            addBackgroundNeurons(10, 55, 60);
        }

        // SECTION 2: Predictive Coding Network — hierarchical prediction/error layers
        function buildPCNetwork() {
            const layers = [3, 5, 5, 3]; // 4 layers representing visual hierarchy V1→V4
            const lSpacing = 26, nSpacing = 11;
            const layerColors = [0x06b6d4, 0x8b5cf6, 0xa78bfa, 0xfbbf24]; // bottom→top
            const layerNames = ['Sensory Input', 'Low-level Features', 'High-level Concepts', 'Abstract Representation'];

            layers.forEach((cnt, li) => {
                const x = (li - (layers.length - 1) / 2) * lSpacing;
                for (let ni = 0; ni < cnt; ni++) {
                    const y = (ni - (cnt - 1) / 2) * nSpacing;
                    const muGeo = createOrganicSoma(3.6, 56, 0.8);
                    const mu = new THREE.Mesh(muGeo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.48, metalness: 0.04, envMap, envMapIntensity: 0.10, emissive: new THREE.Color(layerColors[li]).multiplyScalar(0.15), emissiveIntensity: 0.10 }));
                    mu.position.set(x, y, 0); mu.castShadow = true; mu.name = `mu_${li}_${ni}`; group.add(mu);

                    // Error neuron (ε) — smaller, offset in z, red/orange
                    const epsGeo = new THREE.SphereGeometry(2.0, 32, 32);
                    const eps = new THREE.Mesh(epsGeo, new THREE.MeshStandardMaterial({ color: RED, roughness: 0.40, metalness: 0.05, envMap, envMapIntensity: 0.08, emissive: RED, emissiveIntensity: 0.08, transparent: true, opacity: 0.85 }));
                    eps.position.set(x + 3.0, y - 2.0, 4); eps.name = `eps_${li}_${ni}`; group.add(eps);
                    anims.push({ obj: eps, type: 'errorPulse', phase: Math.random() * TAU, li, ni });

                    // Nucleus
                    const nuc = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 16), wetBioMat(0x3a0828, { rough: 0.4, eI: 0.08 }));
                    nuc.position.set(x, y, 0); group.add(nuc);
                    anims.push({ obj: mu, type: 'muNeuron', li, ni, phase: Math.random() * TAU });

                    // Top-down prediction connections (purple — from layer above to layer below)
                    if (li > 0) {
                        const prevCnt = layers[li - 1];
                        for (let pni = 0; pni < prevCnt; pni++) {
                            if (Math.random() > 0.6) continue;
                            const px = (li - 1 - (layers.length - 1) / 2) * lSpacing, py = (pni - (prevCnt - 1) / 2) * nSpacing;
                            const ctrl = new THREE.Vector3((x + px) / 2 + 2, (y + py) / 2, (Math.random() - 0.5) * 6);
                            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(x, y, 0), ctrl, new THREE.Vector3(px, py, 0)]);
                            const predTube = new THREE.Mesh(new THREE.TubeGeometry(curve, 12, 0.07, 4, false), new THREE.MeshBasicMaterial({ color: 0xa78bfa, transparent: true, opacity: 0.18, blending: THREE.NormalBlending }));
                            predTube.name = `pred_${li}_${ni}_${pni}`; group.add(predTube);
                            // Prediction signal particles
                            const predSig = new THREE.Mesh(new THREE.SphereGeometry(0.42, 8, 8), glowMat(0xa78bfa, 0.9));
                            predSig.name = `predsig_${li}`; predSig.visible = false; group.add(predSig);
                            anims.push({ obj: predSig, type: 'spikeTravel', curve, offset: Math.random(), speed: 0.08, pre: true });
                        }
                    }
                    // Bottom-up error connections (cyan — from error neuron upward)
                    if (li < layers.length - 1) {
                        const nxCnt = layers[li + 1];
                        for (let nxni = 0; nxni < nxCnt; nxni++) {
                            if (Math.random() > 0.55) continue;
                            const nx = (li + 1 - (layers.length - 1) / 2) * lSpacing, ny = (nxni - (nxCnt - 1) / 2) * nSpacing;
                            const ctrl = new THREE.Vector3((x + nx) / 2 - 2, (y + ny) / 2 + 2, (Math.random() - 0.5) * 5);
                            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(x + 2.5, y - 1.5, 4), ctrl, new THREE.Vector3(nx, ny, 0)]);
                            const errTube = new THREE.Mesh(new THREE.TubeGeometry(curve, 12, 0.055, 4, false), new THREE.MeshBasicMaterial({ color: CYAN, transparent: true, opacity: 0.15, blending: THREE.NormalBlending }));
                            errTube.name = `errtube_${li}_${ni}_${nxni}`; group.add(errTube);
                            // Error signal particles
                            const errSig = new THREE.Mesh(new THREE.SphereGeometry(0.38, 8, 8), glowMat(CYAN, 0.9));
                            errSig.name = `errsig2_${li}`; errSig.visible = false; group.add(errSig);
                            anims.push({ obj: errSig, type: 'spikeTravel', curve, offset: Math.random() + 0.5, speed: 0.09, pre: false });
                        }
                    }
                }
                // Layer label ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(layers[li] * nSpacing * 0.45, 0.2, 6, 40), new THREE.MeshBasicMaterial({ color: layerColors[li], transparent: true, opacity: 0.06, blending: THREE.NormalBlending }));
                ring.position.set(x, 0, 0); ring.rotation.y = PI / 2; ring.name = `layerRing_${li}`; group.add(ring);
            });
            addBackgroundNeurons(10, 50, 45);
        }

        // SECTION 3: Error Neuron Circuitry — close-up of single layer pair
        function buildErrorCircuit() {
            // Two paired neurons showing the μ/ε circuitry in detail
            const pairs = [
                { x: -28, y: 10, col: 0x7c3aed },
                { x: -28, y: -10, col: 0x5b21b6 },
                { x: 28, y: 8, col: 0x6d28d9 },
                { x: 28, y: -8, col: 0x4c1d95 },
            ];
            pairs.forEach((p, idx) => {
                // Representational neuron (μ) — large, ultra-realistic
                const geo = createOrganicSoma(5.5, 80, 1.0);
                const mu = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.52, metalness: 0.04, envMap, envMapIntensity: 0.10, emissive: 0x660a2a, emissiveIntensity: 0.25, transparent: true, opacity: 0.97 }));
                mu.position.set(p.x, p.y, 0); mu.castShadow = true; mu.name = `errMu_${idx}`; group.add(mu);
                // Moisture layer
                const moistGeo = new THREE.SphereGeometry(5.65, 40, 40);
                const moist = new THREE.Mesh(moistGeo, new THREE.MeshStandardMaterial({ color: 0x996050, roughness: 0.12, metalness: 0.08, envMap, envMapIntensity: 0.08, emissive: 0x442010, emissiveIntensity: 0.03, transparent: true, opacity: 0.06 }));
                moist.position.set(p.x, p.y, 0); group.add(moist);
                // Nucleus
                const nuc = new THREE.Mesh(new THREE.SphereGeometry(2.3, 24, 24), wetBioMat(0x3a0818, { rough: 0.38, eI: 0.10 }));
                nuc.position.set(p.x, p.y, 0); group.add(nuc);
                // Mitochondria
                for (let m = 0; m < 3; m++) {
                    const mPts = []; const ang = m * TAU / 3;
                    for (let s = 0; s <= 6; s++) { const t = s / 6; mPts.push(new THREE.Vector3(p.x + Math.cos(ang + t * 2) * 2.2, p.y + Math.sin(ang + t * 1.5) * 2 + Math.sin(s * 3) * 0.25, Math.sin(ang + t * 2) * 1.8)); }
                    group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(mPts), 8, 0.25, 6, false), bioMat(0x885544, { rough: 0.48, eI: 0.06 })));
                }
                anims.push({ obj: mu, type: 'muGlow', phase: idx * 1.2 });
                // Blood capillaries
                for (let c = 0; c < 6; c++) {
                    const cp = []; const phi0 = Math.random() * PI, th0 = Math.random() * TAU;
                    for (let s = 0; s <= 12; s++) { const tt = s / 12; cp.push(new THREE.Vector3(p.x + 5.65 * Math.sin(phi0 + tt * 1.2) * Math.cos(th0 + tt * 0.8 + c * 0.5), p.y + 5.65 * Math.cos(phi0 + tt * 1.2), 5.65 * Math.sin(phi0 + tt * 1.2) * Math.sin(th0 + tt * 0.8 + c * 0.5))); }
                    group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(cp), 16, 0.025 + Math.random() * 0.015, 4, false), new THREE.MeshStandardMaterial({ color: 0x8a1510, roughness: 0.45, metalness: 0.06, envMap, envMapIntensity: 0.08, emissive: 0x770a0a, emissiveIntensity: 0.28 })));
                }
                // Corresponding error neuron (ε) — positioned nearby, glowing red
                const epsOff = new THREE.Vector3(p.x > 0 ? 8 : -8, p.y > 0 ? 7 : -7, 6);
                const epsGeo = new THREE.SphereGeometry(3.0, 48, 48);
                const epsMesh = new THREE.Mesh(epsGeo, new THREE.MeshStandardMaterial({ color: RED, roughness: 0.38, metalness: 0.05, envMap, envMapIntensity: 0.10, emissive: RED, emissiveIntensity: 0.15, transparent: true, opacity: 0.92 }));
                epsMesh.position.copy(epsOff); epsMesh.name = `errEps_${idx}`; group.add(epsMesh);
                anims.push({ obj: epsMesh, type: 'errorPulse', phase: idx * 0.8 + 1.5 });
                // Connection: μ → ε (excitatory, white)
                const excPts = [new THREE.Vector3(p.x, p.y, 0), new THREE.Vector3((p.x + epsOff.x) * 0.5, (p.y + epsOff.y) * 0.5, 3), epsOff.clone()];
                const excTube = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(excPts), 10, 0.12, 6, false), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.18, blending: THREE.NormalBlending }));
                group.add(excTube);
                // Prediction signal from above → ε (inhibitory, red)
                const predOff = new THREE.Vector3(epsOff.x, epsOff.y + 12, epsOff.z + 4);
                const inhPts = [predOff.clone(), new THREE.Vector3((epsOff.x + predOff.x) * 0.5, (epsOff.y + predOff.y) * 0.5, epsOff.z + 2), epsOff.clone()];
                const inhTube = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(inhPts), 10, 0.10, 6, false), new THREE.MeshBasicMaterial({ color: 0xa78bfa, transparent: true, opacity: 0.20, blending: THREE.NormalBlending }));
                group.add(inhTube);
                // Error signal traveling up
                const errSig = new THREE.Mesh(new THREE.SphereGeometry(0.55, 8, 8), glowMat(CYAN, 0.95));
                errSig.name = `errSig_${idx}`; errSig.visible = false; group.add(errSig);
                const upCurve = new THREE.CatmullRomCurve3([epsOff.clone(), new THREE.Vector3(epsOff.x, epsOff.y + 8, epsOff.z), new THREE.Vector3(p.x + (p.x > 0 ? -15 : 15), p.y + 18, 0)]);
                anims.push({ obj: errSig, type: 'spikeTravel', curve: upCurve, offset: idx / 4, speed: 0.07 });
            });
            // Connecting axons between the two neuron groups
            const axonPts = [];
            for (let i = 0; i <= 20; i++) {
                const tt = i / 20;
                axonPts.push(new THREE.Vector3(-20 + tt * 40, Math.sin(tt * PI) * 8 + 2, Math.cos(tt * PI * 2) * 3));
            }
            const axonCurve = new THREE.CatmullRomCurve3(axonPts);
            group.add(new THREE.Mesh(new THREE.TubeGeometry(axonCurve, 24, 0.45, 8, false), bioMat(BIO.axon, { rough: 0.5, eI: 0.05 })));
            // Myelin sheaths
            for (let s = 0; s < 5; s++) {
                const t0 = 0.05 + s * 0.17, t1 = t0 + 0.13;
                const sPts = []; for (let j = 0; j <= 8; j++) { const t = t0 + (t1 - t0) * j / 8; sPts.push(axonCurve.getPoint(t)); }
                group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(sPts), 8, 1.0, 8, false), new THREE.MeshStandardMaterial({ color: 0x7a5838, roughness: 0.55, metalness: 0.05, envMap, envMapIntensity: 0.06, emissive: 0x663318, emissiveIntensity: 0.22, transparent: true, opacity: 0.88 })));
            }
            // Spike signals
            for (let i = 0; i < 5; i++) {
                const s = new THREE.Mesh(new THREE.SphereGeometry(0.7, 10, 10), glowMat(BIO.spike, 0.88));
                s.name = `ecSpike_${i}`; s.visible = false; group.add(s);
                anims.push({ obj: s, type: 'spikeTravel', curve: axonCurve, offset: i / 5, speed: 0.11 });
            }
            addBackgroundNeurons(6, 40, 40);
        }

        // SECTION 4: Comparison scene — backprop frozen phases vs PC continuous
        function buildComparison() {
            // Left side: Backprop (orange/red, frozen phases)
            // Right side: Predictive Coding (purple, continuous)
            const W = 3, H = 3, spacing = 14;

            // BACKPROP SIDE (left, x=-40 to -5)
            const bpColors = [0xff6633, 0xff3366, 0xffaa22];
            for (let li = 0; li < W; li++) {
                for (let ni = 0; ni < H; ni++) {
                    const x = -45 + (li * spacing), y = (ni - (H - 1) / 2) * spacing;
                    const geo = createOrganicSoma(3.8, 40, 0.85);
                    const node = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.50, metalness: 0.04, envMap, envMapIntensity: 0.08, emissive: new THREE.Color(bpColors[li % 3]).multiplyScalar(0.08), emissiveIntensity: 0.08 }));
                    node.position.set(x, y, 0); node.name = `cmpBP_${li}_${ni}`; group.add(node);
                    anims.push({ obj: node, type: 'bpCompareFire', li, ni, phase: Math.random() * TAU });
                    if (li < W - 1) {
                        const nx = x + spacing;
                        for (let nj = 0; nj < H; nj++) {
                            const ny = (nj - (H - 1) / 2) * spacing;
                            if (Math.random() > 0.7) continue;
                            const cv = new THREE.CatmullRomCurve3([new THREE.Vector3(x, y, 0), new THREE.Vector3((x + nx) / 2, (y + ny) / 2, (Math.random() - 0.5) * 3), new THREE.Vector3(nx, ny, 0)]);
                            group.add(new THREE.Mesh(new THREE.TubeGeometry(cv, 10, 0.07, 4, false), new THREE.MeshBasicMaterial({ color: 0xff6633, transparent: true, opacity: 0.14, blending: THREE.NormalBlending })));
                        }
                    }
                }
            }
            // Divider line
            const divPts = [new THREE.Vector3(-2, -25, 0), new THREE.Vector3(-2, 25, 0)];
            const divLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(divPts), wireMat(0x444455, 0.4));
            group.add(divLine);

            // PC SIDE (right, x=5 to 40)
            const pcColors = [CYAN, PURPLE, AMBER];
            for (let li = 0; li < W; li++) {
                for (let ni = 0; ni < H; ni++) {
                    const x = 10 + (li * spacing), y = (ni - (H - 1) / 2) * spacing;
                    const geo = createOrganicSoma(3.8, 40, 0.85);
                    const node = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.50, metalness: 0.04, envMap, envMapIntensity: 0.08, emissive: new THREE.Color(pcColors[li % 3]).multiplyScalar(0.08), emissiveIntensity: 0.08 }));
                    node.position.set(x, y, 0); node.name = `cmpPC_${li}_${ni}`; group.add(node);
                    anims.push({ obj: node, type: 'pcCompareFire', li, ni, phase: Math.random() * TAU });
                    // Error neuron (small, cyan)
                    const eps = new THREE.Mesh(new THREE.SphereGeometry(0.9, 16, 16), new THREE.MeshBasicMaterial({ color: CYAN, transparent: true, opacity: 0.6, blending: THREE.NormalBlending }));
                    eps.position.set(x + 2, y - 1.5, 3); eps.name = `cmpEps_${li}_${ni}`; group.add(eps);
                    anims.push({ obj: eps, type: 'errorPulse', phase: Math.random() * TAU + 0.5 });
                    if (li < W - 1) {
                        const nx = x + spacing;
                        for (let nj = 0; nj < H; nj++) {
                            const ny = (nj - (H - 1) / 2) * spacing;
                            if (Math.random() > 0.7) continue;
                            const cv = new THREE.CatmullRomCurve3([new THREE.Vector3(x, y, 0), new THREE.Vector3((x + nx) / 2, (y + ny) / 2, (Math.random() - 0.5) * 3), new THREE.Vector3(nx, ny, 0)]);
                            // Forward (cyan)
                            group.add(new THREE.Mesh(new THREE.TubeGeometry(cv, 10, 0.06, 4, false), new THREE.MeshBasicMaterial({ color: CYAN, transparent: true, opacity: 0.12, blending: THREE.NormalBlending })));
                            // Backward error (purple)
                            group.add(new THREE.Mesh(new THREE.TubeGeometry(cv, 10, 0.04, 4, false), new THREE.MeshBasicMaterial({ color: PURPLE, transparent: true, opacity: 0.10, blending: THREE.NormalBlending })));
                        }
                    }
                }
            }
            // Signals on PC side — bi-directional, continuous - dramatically increased
            for (let i = 0; i < 35; i++) {
                const li = Math.floor(Math.random() * (W - 1));
                const x = 10 + li * spacing, y = (Math.floor(Math.random() * H) - (H - 1) / 2) * spacing;
                const nx = x + spacing, ny = (Math.floor(Math.random() * H) - (H - 1) / 2) * spacing;
                const cv = new THREE.CatmullRomCurve3([new THREE.Vector3(x, y, 0), new THREE.Vector3((x + nx) / 2, (y + ny) / 2, (Math.random() - 0.5) * 4), new THREE.Vector3(nx, ny, 0)]);
                const sig = new THREE.Mesh(new THREE.SphereGeometry(0.65, 12, 12), glowMat(i % 2 === 0 ? PURPLE : CYAN, 0.95));
                sig.name = `pcSig_${i}`; sig.visible = false; group.add(sig);
                anims.push({ obj: sig, type: 'spikeTravel', curve: cv, offset: i / 8, speed: 0.10, pre: i % 2 === 0 });
            }
            addBackgroundNeurons(8, 55, 45);
        }

        // SECTION 5: Future — full-scale predictive hierarchy with generative/discriminative modes
        function buildFuture() {
            const layers = [4, 6, 8, 6, 4];
            const lSpacing = 22, nSpacing = 9.5;
            // Full hierarchical PC network, larger and more elaborate
            layers.forEach((cnt, li) => {
                const x = (li - (layers.length - 1) / 2) * lSpacing;
                const hue = li / layers.length; // 0=cyan, 1=purple
                const col = new THREE.Color().setHSL(0.72 + hue * 0.15, 0.7, 0.6);
                for (let ni = 0; ni < cnt; ni++) {
                    const y = (ni - (cnt - 1) / 2) * nSpacing;
                    const geo = createOrganicSoma(3.0, 48, 0.8);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.48, metalness: 0.04, envMap, envMapIntensity: 0.10, emissive: col.clone().multiplyScalar(0.15), emissiveIntensity: 0.10 }));
                    mesh.position.set(x, y, 0); mesh.castShadow = true; mesh.name = `fut_${li}_${ni}`; group.add(mesh);
                    anims.push({ obj: mesh, type: 'futureNeuron', li, ni, phase: Math.random() * TAU, layers: layers.length });
                    // Nucleus
                    group.add(new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), wetBioMat(0x3a0828, { rough: 0.4, eI: 0.08 })).translateX(x).translateY(y));
                    // Error neuron
                    const eps = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshBasicMaterial({ color: RED, transparent: true, opacity: 0.5, blending: THREE.NormalBlending }));
                    eps.position.set(x + 2.2, y - 1.2, 3); eps.name = `futEps_${li}_${ni}`; group.add(eps);
                    anims.push({ obj: eps, type: 'errorPulse', phase: Math.random() * TAU });
                    // Bidirectional connections to next layer
                    if (li < layers.length - 1) {
                        const nCnt = layers[li + 1];
                        for (let nj = 0; nj < nCnt; nj++) {
                            if (Math.random() > 0.45) continue;
                            const nx = (li + 1 - (layers.length - 1) / 2) * lSpacing, ny = (nj - (nCnt - 1) / 2) * nSpacing;
                            const ctrl = new THREE.Vector3((x + nx) / 2, (y + ny) / 2, (Math.random() - 0.5) * 5);
                            const cv = new THREE.CatmullRomCurve3([new THREE.Vector3(x, y, 0), ctrl, new THREE.Vector3(nx, ny, 0)]);
                            // Bottom-up error (cyan)
                            group.add(new THREE.Mesh(new THREE.TubeGeometry(cv, 10, 0.05, 4, false), new THREE.MeshBasicMaterial({ color: CYAN, transparent: true, opacity: 0.11, blending: THREE.NormalBlending })));
                            // Top-down prediction (purple)
                            group.add(new THREE.Mesh(new THREE.TubeGeometry(cv, 10, 0.07, 4, false), new THREE.MeshBasicMaterial({ color: PURPLE, transparent: true, opacity: 0.14, blending: THREE.NormalBlending })));
                            // Signal particles
                            const sig = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), glowMat(Math.random() > 0.5 ? CYAN : PURPLE, 0.9));
                            sig.name = `futSig_${li}_${ni}`; sig.visible = false; group.add(sig);
                            anims.push({ obj: sig, type: 'spikeTravel', curve: cv, offset: Math.random(), speed: 0.09, pre: Math.random() > 0.5 });
                        }
                    }
                }
            });
            // Orbiting feature spheres (generative outputs)
            for (let i = 0; i < 6; i++) {
                const geo = [new THREE.IcosahedronGeometry(2.5, 1), new THREE.OctahedronGeometry(2.5, 1), new THREE.DodecahedronGeometry(2.0, 1)][i % 3];
                const mat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color().setHSL(0.7 + i * 0.05, 0.7, 0.5), roughness: 0.08, metalness: 0.7, envMap, envMapIntensity: 3.0, clearcoat: 1.0, clearcoatRoughness: 0.02, emissive: new THREE.Color().setHSL(0.7 + i * 0.05, 0.8, 0.3), emissiveIntensity: 0.12 });
                const orb = new THREE.Mesh(geo, mat); orb.name = `futOrb_${i}`; group.add(orb);
                anims.push({ obj: orb, type: 'orbit', r: 70, speed: 0.06 + i * 0.02, phase: i * TAU / 6, yOff: 2 });
            }
            addBackgroundNeurons(12, 55, 50);
        }

        // SECTION 6: End card — single beautiful neuron with full environment
        function buildEndCard() {
            const geo = createOrganicSoma(8, 96, 1.0);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.50, metalness: 0.04, envMap, envMapIntensity: 0.10, emissive: 0x660a2a, emissiveIntensity: 0.30, transparent: true, opacity: 0.97 }));
            mesh.name = 'endSoma'; group.add(mesh);
            // Large moisture overlay
            const moist = new THREE.Mesh(new THREE.SphereGeometry(8.2, 48, 48), new THREE.MeshStandardMaterial({ color: 0x996050, roughness: 0.10, metalness: 0.08, envMap, envMapIntensity: 0.10, transparent: true, opacity: 0.06 }));
            group.add(moist);
            // Nucleus
            group.add(new THREE.Mesh(new THREE.SphereGeometry(3.2, 32, 32), wetBioMat(0x3a0818, { rough: 0.38, eI: 0.10 })));
            // Dendrites
            for (let d = 0; d < 6; d++) {
                const dir = new THREE.Vector3(Math.cos(d * TAU / 6 + 0.5), Math.sin(d * TAU / 6) * 0.6 + (Math.random() - 0.5) * 0.4, (Math.random() - 0.5) * 0.5).normalize();
                const pts = [];
                for (let s = 0; s <= 14; s++) { const t = s / 14; pts.push(new THREE.Vector3(dir.x * t * 18 + (Math.random() - 0.5) * 0.6, dir.y * t * 18 + (Math.random() - 0.5) * 0.6, dir.z * t * 18 + (Math.random() - 0.5) * 0.6)); }
                group.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 18, 0.55 * (1 - d * 0.04), 8, false), bioMat(BIO.axon, { rough: 0.52, eI: 0.08 })));
            }
            // Glowing error signals converging
            for (let i = 0; i < 8; i++) {
                const angle = i * TAU / 8, r = 40;
                const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(Math.cos(angle) * r, (Math.random() - 0.5) * 15, Math.sin(angle) * r), new THREE.Vector3(Math.cos(angle) * r * 0.4, (Math.random() - 0.5) * 6, Math.sin(angle) * r * 0.4), new THREE.Vector3(0, 0, 0)]);
                const sig = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), glowMat(i % 2 === 0 ? PURPLE : CYAN, 0.9));
                sig.name = `endSig_${i}`; sig.visible = false; group.add(sig);
                anims.push({ obj: sig, type: 'spikeTravel', curve, offset: i / 8, speed: 0.08 });
                // The arc line
                const arcGeo = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));
                group.add(new THREE.Line(arcGeo, wireMat(i % 2 === 0 ? PURPLE : CYAN, 0.08)));
            }
            addBackgroundNeurons(14, 60, 55);
        }

        let visualStateMap = [
            {},
            { 0: 'bpIntro', 1: 'bpForward', 2: 'bpFrozen', 3: 'bpErrors', 4: 'bpController', 5: 'bpNoCoord' },
            { 0: 'pcIntro', 1: 'pcPredict', 2: 'pcEnergy', 3: 'pcDescent', 4: 'pcBalance', 5: 'pcEquilibrium' },
            { 0: 'errTypes', 1: 'errNeurons', 2: 'errInputs', 3: 'errCircuit', 4: 'errHebbian', 5: 'errPlasticity' },
            { 0: 'cmpLocal', 1: 'cmpNoCoord', 2: 'cmpContinuous', 3: 'cmpCompare', 4: 'cmpForgetting', 5: 'cmpResult' },
            { 0: 'futParallel', 1: 'futEfficiency', 2: 'futGenerative', 3: 'futBridge', 4: 'futConvergence', 5: 'futFinale' },
            {}
        ];

        function loadSection(idx) {
            current = idx; currentNarrative = 0; narrativeTimer = 0; sectionStartTime = clock.getElapsedTime();
            // Flash
            const fl = document.getElementById('sectionFlash'); if (fl) { fl.style.opacity = '1'; setTimeout(() => { fl.style.opacity = '0'; }, 60); }
            // Pulse ring
            const pr = document.getElementById('pulseRing'); if (pr) { pr.classList.remove('fire'); void pr.offsetWidth; pr.classList.add('fire'); }
            // Clear
            while (group.children.length > 0) { const c = group.children[0]; if (c.geometry) c.geometry.dispose(); if (c.material) { if (Array.isArray(c.material)) c.material.forEach(m => m.dispose()); else c.material.dispose(); } group.remove(c); }
            anims = [];
            // Build
            try {
                if (idx === 0) { buildPCNetwork(); } // Intro: show the full network
                else if (idx === 1) { buildBackprop(); }
                else if (idx === 2) { buildPCNetwork(); }
                else if (idx === 3) { buildErrorCircuit(); }
                else if (idx === 4) { buildComparison(); }
                else if (idx === 5) { buildFuture(); }
                else if (idx === 6) { buildEndCard(); }
            } catch (e) { console.error('Build error:', e); }
            updateUI();
        }

        function updateUI() {
            const sec = sections[current];
            // Update overlay text
            const archTitle = document.getElementById('archTitle'); const archSubtitle = document.getElementById('archSubtitle'); const archYear = document.getElementById('archYear');
            const eqLabel = document.getElementById('eqLabel'); const eqMath = document.getElementById('eqMath');
            if (archTitle) archTitle.textContent = sec.name || '';
            if (archSubtitle) archSubtitle.textContent = sec.subtitle || '';
            if (archYear) archYear.textContent = sec.year || '';
            if (eqLabel) eqLabel.textContent = sec.eqLabel || '';
            if (eqMath && sec.equation !== undefined) eqMath.innerHTML = sec.equation || '';

            const scriptSub = document.getElementById('scriptSub'); const scriptText = document.getElementById('scriptText');
            if (sec.hideScript) { if (scriptSub) scriptSub.textContent = ''; if (scriptText) { scriptText.classList.remove('active'); scriptText.innerHTML = ''; } }
            else {
                const narr = sec.narratives[currentNarrative];
                if (scriptSub && narr) scriptSub.textContent = narr.title || '';
                if (scriptText && narr) { scriptText.classList.remove('active'); void scriptText.offsetWidth; scriptText.innerHTML = narr.text || ''; setTimeout(() => scriptText.classList.add('active'), 50); }
            }

            // HUD
            const hudL = document.getElementById('hudLeft'); const hudR = document.getElementById('hudRight');
            const errVal = (Math.random() * 0.8).toFixed(3);
            if (hudL) hudL.innerHTML = `PC_NET v2.0<br>LAYERS: ${[0, 4, 4, 2, 6, 5, 4][current] || 4}<br>ε_TOTAL: ${errVal}<br>INFERENCE: ACTIVE`;
            if (hudR) hudR.innerHTML = `PRED_ERR: ${(Math.random() * 0.5).toFixed(3)}<br>WEIGHT_Δ: LOCAL<br>CONVERGENCE: ${Math.floor(Math.random() * 200 + 50)} ITER`;

            // Visual mode
            const modes = visualStateMap[current] || {};
            visualState.mode = modes[currentNarrative] || 'idle';

            // End card
            const endCard = document.getElementById('endCardOverlay');
            if (endCard) { if (current === sections.length - 1) endCard.classList.add('active'); else endCard.classList.remove('active'); }
            // Intro card
            const introCard = document.getElementById('introCardOverlay');
            if (introCard && current > 0) introCard.classList.add('fade-out');
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2b2e4a);
            scene.fog = new THREE.FogExp2(0x2b2e4a, 0.001);
            camera = new THREE.PerspectiveCamera(32, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 35, 130);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2.5));
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.25;
            renderer.outputEncoding = THREE.sRGBEncoding;

            // Post-processing
            try {
                if (THREE.EffectComposer && THREE.RenderPass && THREE.UnrealBloomPass && THREE.ShaderPass) {
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(new THREE.RenderPass(scene, camera));
                    bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.50, 0.55, 0.85);
                    composer.addPass(bloomPass);
                    const cinShader = {
                        uniforms: { tDiffuse: { value: null }, time: { value: 0 }, chromAb: { value: 0.0018 }, grainI: { value: 0.013 }, res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
                        vertexShader: 'varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}',
                        fragmentShader: 'uniform sampler2D tDiffuse;uniform float time,chromAb,grainI;uniform vec2 res;varying vec2 vUv;float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}void main(){vec2 uv=vUv,c=uv-0.5;float d=length(c);float ab=chromAb*d*d;float r=texture2D(tDiffuse,uv+c*ab).r;float g=texture2D(tDiffuse,uv).g;float b=texture2D(tDiffuse,uv-c*ab).b;vec3 col=vec3(r,g,b);float grain=(hash(uv*res+time*100.0)*2.0-1.0)*0.5;col+=grain*grainI;gl_FragColor=vec4(col,1.0);}'
                    };
                    cinematicPass = new THREE.ShaderPass(cinShader);
                    composer.addPass(cinematicPass);
                } else { composer = null; }
            } catch (e) { composer = null; console.warn('Post-processing failed:', e); }

            envMap = createEnvMap();
            setupLights(); createBG();
            group = new THREE.Group(); scene.add(group);
            animate();
            try { loadSection(0); } catch (e) { console.error('loadSection error:', e); }
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKey);
            // Click/tap to advance
            document.addEventListener('click', () => {
                if (current === 0) { loadSection(1); return; }
                if (currentNarrative < sections[current].narratives.length - 1) { currentNarrative++; updateUI(); }
                else loadSection((current + 1) % sections.length);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!renderer || !scene || !camera) return;
            const delta = clock.getDelta(), t = clock.getElapsedTime();
            try {
                if (isPlaying) {
                    narrativeTimer += delta;
                    const narDur = (current === 0 || current === sections.length - 1) ? 5 : NARR_DUR;
                    if (narrativeTimer >= narDur) {
                        narrativeTimer = 0; currentNarrative++;
                        if (currentNarrative >= sections[current].narratives.length) { currentNarrative = 0; loadSection((current + 1) % sections.length); }
                        else updateUI();
                    }
                }

                if (!group || !group.children) { if (composer) { try { composer.render(); } catch (e) { renderer.render(scene, camera); } } else renderer.render(scene, camera); return; }

                group.rotation.y += delta * 0.09;

                // Animate dust
                const dustObj = scene.getObjectByName('_dust');
                if (dustObj) { const dp = dustObj.geometry.attributes.position; for (let i = 0; i < dp.count; i++) { dp.setY(i, dp.getY(i) + Math.sin(t * 0.3 + i * 0.1) * 0.007); dp.setX(i, dp.getX(i) + Math.cos(t * 0.2 + i * 0.07) * 0.004); } dp.needsUpdate = true; dustObj.rotation.y = t * 0.01; }
                // Bokeh
                const bokehObj = scene.getObjectByName('_bokeh');
                if (bokehObj) { bokehObj.rotation.y = t * 0.005; const bp = bokehObj.geometry.attributes.position; for (let i = 0; i < bp.count; i++) { bp.setY(i, bp.getY(i) + Math.sin(t * 0.15 + i * 0.4) * 0.007); } bp.needsUpdate = true; }
                // Fog planes
                scene.children.filter(c => c.name === '_fogPlane').forEach((fp, i) => { fp.position.x += Math.sin(t * 0.025 + i * 1.5) * 0.04; fp.rotation.z += 0.0003; fp.material.opacity = 0.018 + Math.sin(t * 0.1 + i) * 0.008; });
                // Energy rings
                for (let i = 0; i < 3; i++) { const er = scene.getObjectByName('_eRing_' + i); if (er) { er.rotation.z = t * 0.07 * (i + 1); er.rotation.x = PI / 2 + i * 0.15 + Math.sin(t * 0.2 + i) * 0.05; er.material.opacity = 0.025 + Math.sin(t * 0.45 + i * 2) * 0.012; } }
                // God rays
                scene.children.filter(c => c.name === '_godRay').forEach((gr, i) => { gr.rotation.z = Math.sin(t * 0.05 + i) * 0.02; gr.material.opacity = 0.013 + Math.sin(t * 0.2 + i * 0.7) * 0.007; });
                // Light leak
                const llEl = document.getElementById('lightLeak'); if (llEl) { const lk = Math.sin(t * 0.11) * 0.5 + 0.5; llEl.style.opacity = (lk > 0.88 ? (lk - 0.88) * 2.5 : 0).toFixed(3); }
                // Anamorphic streak
                const ask = document.getElementById('anamStreak'); if (ask) { const so2 = Math.sin(t * 0.28) * 0.10 + 0.03; if (so2 > 0) ask.style.opacity = so2.toFixed(3); }

                // ─── Per-animation updates ───
                anims.forEach(a => {
                    if (!a.obj || !a.obj.parent) return;
                    switch (a.type) {
                        case 'spikeTravel': {
                            if (!a.curve) break;
                            const prog = ((t * a.speed + a.offset) % 1 + 1) % 1;
                            try {
                                const pt = a.curve.getPoint(a.pre ? prog : 1 - prog);
                                a.obj.position.copy(pt);
                                a.obj.visible = prog > 0.05 && prog < 0.95;
                            } catch (e) { a.obj.visible = false; }
                            break;
                        }
                        case 'bgNeuronPulse': { const pulse = (Math.sin(t * 1.8 + a.phase) + 1) * 0.5; if (a.obj.material) { a.obj.material.emissiveIntensity = 0.06 + pulse * 0.14; a.obj.material.opacity = 0.40 + pulse * 0.22; } break; }
                        case 'errorPulse': { const pulse = (Math.sin(t * 3.5 + a.phase) + 1) * 0.5; if (a.obj.material) { a.obj.material.opacity = 0.3 + pulse * 0.55; a.obj.material.emissiveIntensity = 0.05 + pulse * 0.20; } a.obj.scale.setScalar(0.85 + pulse * 0.30); break; }
                        case 'muNeuron': case 'muGlow': { if (a.obj.material) { const glow = Math.sin(t * 1.2 + a.phase) * 0.5 + 0.5; a.obj.material.emissiveIntensity = 0.08 + glow * 0.14; } break; }
                        case 'bpNeuron': {
                            // Alternates: forward (white), frozen (blue), backward (red)
                            const cycle = t % 9;
                            const phase = a.li * 0.3 + a.ni * 0.15;
                            if (cycle < 3) {// forward pass
                                const v = Math.sin((t - phase) * 3); a.obj.material.emissiveIntensity = Math.max(0, v) * 0.25;
                            } else if (cycle < 6) {// frozen
                                a.obj.material.emissiveIntensity = 0.02;
                            } else {// backward pass
                                const v = Math.sin((t + phase) * 3); a.obj.material.emissiveIntensity = Math.max(0, v) * 0.18;
                            }
                            break;
                        }
                        case 'bpCompareFire': { const cycle = t % 8; const ph = a.li * 0.4 + a.ni * 0.2; if (cycle < 3) { const v = Math.sin((t - ph) * 3); if (a.obj.material) a.obj.material.emissiveIntensity = Math.max(0, v) * 0.22; } else { if (a.obj.material) a.obj.material.emissiveIntensity = 0.02; } break; }
                        case 'pcCompareFire': { const v = Math.sin(t * 2 + a.li * 0.7 + a.ni * 0.3); if (a.obj.material) a.obj.material.emissiveIntensity = Math.max(0, v) * 0.20; break; }
                        case 'futureNeuron': { const v = Math.sin(t * 1.5 + a.phase); if (a.obj.material) a.obj.material.emissiveIntensity = 0.06 + Math.max(0, v) * 0.18; break; }
                        case 'orbit': { a.obj.position.set(Math.cos(t * a.speed + a.phase) * a.r, a.yOff + Math.sin(t * a.speed * 0.4 + a.phase) * 12, Math.sin(t * a.speed + a.phase) * a.r); a.obj.rotation.x = t * 0.3; a.obj.rotation.y = t * 0.2; break; }
                        case 'burst': {
                            a.life += delta;
                            if (a.life < a.maxLife) {
                                const bp = a.obj.geometry.attributes.position;
                                for (let i = 0; i < bp.count; i++) { bp.setX(i, bp.getX(i) + a.vel[i * 3] * delta * 2); bp.setY(i, bp.getY(i) + a.vel[i * 3 + 1] * delta * 2); bp.setZ(i, bp.getZ(i) + a.vel[i * 3 + 2] * delta * 2); }
                                bp.needsUpdate = true;
                                a.obj.material.opacity = 0.6 * (1 - a.life / a.maxLife);
                            } else { a.obj.visible = false; }
                            break;
                        }
                        case 'vesselPulse': { const pulse = Math.sin(t * 1.4 + a.phase); if (a.obj.material && a.obj.material.emissiveIntensity !== undefined) a.obj.material.emissiveIntensity = 0.22 + Math.max(0, pulse) * 0.10; break; }
                    }
                });

                // ─── Section-specific visual states ───
                const getObjs = (pfx) => group.children.filter(c => c.name && c.name.startsWith(pfx));
                switch (visualState.mode) {
                    case 'bpIntro':
                        getObjs('bp_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.05 + Math.sin(t * 2) * 0.05; });
                        getObjs('fwd_').forEach(n => { if (n.material) n.material.opacity = 0.05; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        break;
                    case 'bpForward':
                        getObjs('bp_').forEach(n => { const li = parseInt(n.name.split('_')[1]); const v = Math.sin(t * 3 - li * 0.8); if (n.material) n.material.emissiveIntensity = Math.max(0, v) * 0.30; });
                        getObjs('fwd_').forEach(n => { if (n.material) n.material.opacity = 0.20 + Math.sin(t * 2) * 0.10; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        getObjs('freeze_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        getObjs('errsig_').forEach(n => { n.visible = false; });
                        break;
                    case 'bpFrozen':
                        // Frozen state: all neurons dimmed, ice-blue rings appear
                        getObjs('bp_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.015; });
                        getObjs('freeze_').forEach((n, i) => { if (n.material) n.material.opacity = 0.18 + Math.sin(t * 2 + i * 0.5) * 0.08; });
                        getObjs('errsig_').forEach(n => { n.visible = false; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.02; });
                        if (bloomPass) bloomPass.strength = 0.45 + Math.sin(t * 0.5) * 0.1;
                        break;
                    case 'bpErrors':
                        getObjs('bp_').forEach((n, i) => { const v = Math.sin(t * 1.5 + i * 0.3); if (n.material) n.material.emissiveIntensity = 0.02 + Math.max(0, v) * 0.10; });
                        getObjs('freeze_').forEach(n => { if (n.material) n.material.opacity = 0.3 + Math.sin(t * 5) * 0.2; });
                        getObjs('errsig_').forEach(n => { n.visible = true; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.18 + Math.sin(t) * 0.08; });
                        break;
                    case 'bpController':
                        getObjs('bp_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.15 + Math.sin(t * 8) * 0.2; });
                        getObjs('freeze_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        getObjs('errsig_').forEach(n => { n.visible = true; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.25; });
                        break;
                    case 'bpNoCoord':
                        getObjs('bp_').forEach((n, i) => { const v = Math.sin(t * 5 + i * 0.8); if (n.material) n.material.emissiveIntensity = Math.max(0, v) * 0.18; });
                        getObjs('freeze_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        getObjs('errsig_').forEach(n => { n.visible = false; });
                        getObjs('bwd_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        getObjs('fwd_').forEach(n => { if (n.material) n.material.opacity = 0.0; });
                        break;

                    case 'pcIntro':
                        getObjs('mu_').forEach((n, i) => { const v = Math.cos(t * 1.5 + i * 0.2); if (n.material) n.material.emissiveIntensity = 0.05 + Math.max(0, v) * 0.10; });
                        getObjs('predsig_').forEach(n => { n.visible = false; });
                        getObjs('errsig2_').forEach(n => { n.visible = false; });
                        break;
                    case 'pcPredict':
                        // Prediction signals flowing downward (purple)
                        getObjs('predsig_').forEach(n => { n.visible = true; });
                        getObjs('errsig2_').forEach(n => { n.visible = false; });
                        getObjs('pred_').forEach(n => { if (n.material) n.material.opacity = 0.25 + Math.sin(t * 2) * 0.1; });
                        getObjs('mu_').forEach((n, i) => { const v = Math.sin(t * 1.5 + i * 0.3); if (n.material) n.material.emissiveIntensity = 0.08 + Math.max(0, v) * 0.18; });
                        break;
                    case 'pcEnergy':
                        // All errors glowing — energy minimization
                        getObjs('eps_').forEach((n, i) => { const e = Math.abs(Math.sin(t * 2 + i * 0.4)); if (n.material) { n.material.opacity = 0.4 + e * 0.5; n.material.emissiveIntensity = 0.08 + e * 0.25; } n.scale.setScalar(0.9 + e * 0.4); });
                        getObjs('errsig2_').forEach(n => { n.visible = true; });
                        if (bloomPass) bloomPass.strength = 0.5 + Math.sin(t * 0.4) * 0.2;
                        break;
                    case 'pcDescent':
                        getObjs('eps_').forEach((n, i) => { const e = Math.abs(Math.cos(t * 3 + i * 0.7)); if (n.material) { n.material.opacity = 0.2 + e * 0.3; n.material.emissiveIntensity = 0.05 + e * 0.15; } n.scale.setScalar(1.0 + e * 0.2); });
                        getObjs('mu_').forEach((n, i) => { const v = Math.sin(t * 3 + i * 0.9); if (n.material) n.material.emissiveIntensity = 0.12 + Math.max(0, v) * 0.2; });
                        getObjs('errsig2_').forEach(n => { n.visible = true; });
                        break;
                    case 'pcBalance':
                        // Neurons settling — oscillating then stabilizing
                        getObjs('mu_').forEach((n, i) => { const decay = Math.max(0, 1 - ((t % 8) / 8)); const osc = Math.sin(t * 4 * decay + i * 0.5) * decay; if (n.material) n.material.emissiveIntensity = 0.08 + Math.abs(osc) * 0.15; n.scale.setScalar(1 + Math.abs(osc) * 0.08); });
                        getObjs('predsig_').forEach(n => { n.visible = true; });
                        getObjs('eps_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.02; n.scale.setScalar(0.85); });
                        break;
                    case 'pcEquilibrium':
                        getObjs('mu_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.03 + Math.sin(t * 0.5) * 0.02; n.scale.setScalar(1); });
                        getObjs('eps_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.01; n.scale.setScalar(0.8); });
                        getObjs('predsig_').forEach(n => { n.visible = false; });
                        getObjs('errsig2_').forEach(n => { n.visible = false; });
                        if (bloomPass) bloomPass.strength = 0.35 + Math.sin(t * 0.2) * 0.05;
                        break;

                    case 'errTypes':
                        getObjs('errMu_').forEach((n, i) => { if (n.material) n.material.emissiveIntensity = 0.05 + Math.sin(t * 1.5 + i * 0.8) * 0.05; });
                        getObjs('errEps_').forEach((n, i) => { if (n.material) { n.material.opacity = 0.2; n.material.emissiveIntensity = 0.02; } });
                        getObjs('errSig_').forEach(n => { n.visible = false; });
                        getObjs('ecSpike_').forEach(n => { n.visible = false; });
                        break;
                    case 'errNeurons':
                        getObjs('errMu_').forEach((n, i) => { if (n.material) n.material.emissiveIntensity = 0.05 + Math.sin(t * 1.5 + i * 0.8) * 0.05; });
                        getObjs('errEps_').forEach((n, i) => { const p = Math.abs(Math.sin(t * 3 + i * 1.2)); if (n.material) { n.material.opacity = 0.5 + p * 0.4; n.material.emissiveIntensity = 0.10 + p * 0.22; } });
                        break;
                    case 'errInputs':
                        getObjs('errMu_').forEach((n, i) => { if (n.material) n.material.emissiveIntensity = 0.15 + Math.sin(t * 4 + i * 0.8) * 0.15; });
                        getObjs('errEps_').forEach(n => { if (n.material) { n.material.opacity = 0.2; n.material.emissiveIntensity = 0.02; } });
                        break;
                    case 'errCircuit':
                        // Error signals traveling up
                        getObjs('errSig_').forEach(n => { n.visible = true; });
                        getObjs('ecSpike_').forEach(n => { n.visible = true; });
                        getObjs('errEps_').forEach((n, i) => { const p = (Math.sin(t * 4 + i * 1.5) + 1) * 0.5; if (n.material) { n.material.opacity = 0.4 + p * 0.55; n.material.emissiveIntensity = 0.08 + p * 0.28; } n.scale.setScalar(0.9 + p * 0.35); });
                        break;
                    case 'errHebbian':
                        // Hebbian weight changes — connections brighten as neurons co-fire
                        getObjs('errMu_').forEach((n, i) => { const v = Math.sin(t * 2 + i * 0.6); if (n.material) n.material.emissiveIntensity = 0.12 + Math.max(0, v) * 0.22; });
                        getObjs('errEps_').forEach((n, i) => { const v = Math.sin(t * 2 + i * 0.6 + 0.5); if (n.material) { n.material.opacity = 0.4 + Math.max(0, v) * 0.5; n.material.emissiveIntensity = 0.10 + Math.max(0, v) * 0.22; } });
                        if (bloomPass) bloomPass.strength = 0.5 + Math.sin(t * 0.3) * 0.15;
                        break;
                    case 'errPlasticity':
                        getObjs('errMu_').forEach((n, i) => { const v = Math.sin(t * 6 + i * 0.9); if (n.material) n.material.emissiveIntensity = 0.2 + Math.max(0, v) * 0.3; });
                        getObjs('errEps_').forEach((n, i) => { const v = Math.sin(t * 6 + i * 0.9 + 0.2); if (n.material) { n.material.opacity = 0.6 + Math.max(0, v) * 0.4; n.material.emissiveIntensity = 0.15 + Math.max(0, v) * 0.3; } });
                        if (bloomPass) bloomPass.strength = 0.6 + Math.sin(t * 1.5) * 0.2;
                        break;

                    case 'cmpLocal':
                        // PC side: neurons glowing in parallel; BP side: sequential
                        getObjs('cmpPC_').forEach((n, i) => { const v = Math.sin(t * 2 + i * 0.2); if (n.material) n.material.emissiveIntensity = 0.08 + Math.max(0, v) * 0.22; });
                        getObjs('cmpBP_').forEach((n, i) => { const li = parseInt(n.name.split('_')[1]); const v = Math.sin(t * 2 - li * 1.5); if (n.material) n.material.emissiveIntensity = Math.max(0, v) * 0.22; });
                        getObjs('cmpEps_').forEach((n, i) => { const p = (Math.sin(t * 3 + i * 0.5) + 1) * 0.5; if (n.material) n.material.opacity = 0.3 + p * 0.5; });
                        getObjs('pcSig_').forEach(n => { n.visible = false; });
                        break;
                    case 'cmpNoCoord':
                        getObjs('cmpPC_').forEach((n, i) => { const v = Math.sin(t * 4 + i * 1.2); if (n.material) n.material.emissiveIntensity = 0.10 + Math.max(0, v) * 0.25; });
                        getObjs('cmpBP_').forEach((n, i) => { if (n.material) n.material.emissiveIntensity = 0.01; });
                        break;
                    case 'cmpContinuous':
                        // PC: always on; BP: flashing between phases
                        getObjs('cmpPC_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.14 + Math.sin(t * 1.5) * 0.08; });
                        { const cycle = t % 6; getObjs('cmpBP_').forEach(n => { if (n.material) n.material.emissiveIntensity = cycle < 3 ? 0.08 : 0.01; }); }
                        getObjs('pcSig_').forEach(n => { n.visible = true; });
                        break;
                    case 'cmpCompare':
                        getObjs('cmpPC_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.2; });
                        getObjs('cmpBP_').forEach(n => { if (n.material) n.material.emissiveIntensity = 0.2; });
                        getObjs('cmpEps_').forEach((n) => { if (n.material) n.material.opacity = 0.6; });
                        break;
                    case 'cmpForgetting':
                        getObjs('cmpPC_').forEach((n, i) => { const v = Math.sin(t * 1.5 + i * 0.4); if (n.material) n.material.emissiveIntensity = 0.05 + Math.max(0, v) * 0.15; });
                        getObjs('cmpBP_').forEach((n, i) => { const v = Math.sin(t * 6 + i * 0.8); if (n.material) n.material.emissiveIntensity = 0.05 + Math.max(0, v) * 0.3; });
                        break;
                    case 'cmpResult':
                        getObjs('cmpPC_').forEach((n, i) => { const v = Math.sin(t * 3 + i * 0.3); if (n.material) n.material.emissiveIntensity = 0.15 + Math.max(0, v) * 0.2; });
                        getObjs('cmpBP_').forEach((n, i) => { const v = Math.sin(t * 3 + i * 0.3); if (n.material) n.material.emissiveIntensity = 0.15 + Math.max(0, v) * 0.2; });
                        break;

                    case 'futParallel':
                        getObjs('fut_').forEach((n, i) => { const v = Math.sin(t * 2 + i * 0.15); if (n.material) n.material.emissiveIntensity = 0.06 + Math.max(0, v) * 0.20; });
                        getObjs('futSig_').forEach(n => { n.visible = true; });
                        break;
                    case 'futEfficiency':
                        getObjs('fut_').forEach((n, i) => { const v = Math.sin(t * 5 + i * 1.2); if (n.material) n.material.emissiveIntensity = 0.02 + Math.max(0, v) * 0.08; });
                        getObjs('futEps_').forEach((n, i) => { if (n.material) n.material.opacity = 0.1; });
                        getObjs('futOrb_').forEach((n, i) => { if (n.material && n.material.emissiveIntensity !== undefined) { n.material.emissiveIntensity = 0.02; } });
                        if (bloomPass) bloomPass.strength = 0.2;
                        break;
                    case 'futGenerative':
                        getObjs('futOrb_').forEach((n, i) => { if (n.material && n.material.emissiveIntensity !== undefined) { n.material.emissiveIntensity = 0.10 + Math.sin(t * 1.5 + i) * 0.08; } });
                        getObjs('fut_').forEach((n, i) => { const v = (Math.sin(t * 1.2 + i * 0.4) + 1) * 0.5; if (n.material) n.material.emissiveIntensity = 0.06 + v * 0.15; });
                        if (bloomPass) bloomPass.strength = 0.55 + Math.sin(t * 0.3) * 0.15;
                        break;
                    case 'futBridge':
                        // All elements fully active, maximum beauty
                        getObjs('fut_').forEach((n, i) => { const v = Math.sin(t * 2 + i * 0.25); if (n.material) n.material.emissiveIntensity = 0.10 + Math.max(0, v) * 0.25; });
                        getObjs('futEps_').forEach((n, i) => { const p = (Math.sin(t * 4 + i * 0.6) + 1) * 0.5; if (n.material) n.material.opacity = 0.35 + p * 0.55; });
                        getObjs('futOrb_').forEach((n, i) => { if (n.material && n.material.emissiveIntensity !== undefined) n.material.emissiveIntensity = 0.12 + Math.sin(t * 1.8 + i) * 0.10; });
                        if (bloomPass) bloomPass.strength = 0.6 + Math.sin(t * 0.25) * 0.2;
                        break;
                    case 'futConvergence':
                        getObjs('fut_').forEach((n, i) => { const v = Math.sin(t * 4 + i * 0.5); if (n.material) n.material.emissiveIntensity = 0.15 + Math.max(0, v) * 0.3; });
                        getObjs('futEps_').forEach((n, i) => { const p = (Math.sin(t * 8 + i * 1.2) + 1) * 0.5; if (n.material) n.material.opacity = 0.5 + p * 0.5; });
                        getObjs('futOrb_').forEach((n, i) => { if (n.material && n.material.emissiveIntensity !== undefined) n.material.emissiveIntensity = 0.2 + Math.sin(t * 3 + i) * 0.15; });
                        if (bloomPass) bloomPass.strength = 0.7 + Math.sin(t * 0.5) * 0.3;
                        break;
                    case 'futFinale':
                        getObjs('fut_').forEach((n, i) => { if (n.material) n.material.emissiveIntensity = 0.3; });
                        getObjs('futEps_').forEach((n, i) => { if (n.material) n.material.opacity = 0.9; });
                        getObjs('futOrb_').forEach((n, i) => { if (n.material && n.material.emissiveIntensity !== undefined) n.material.emissiveIntensity = 0.4; });
                        getObjs('futSig_').forEach(n => { n.visible = true; });
                        if (bloomPass) bloomPass.strength = 1.2 + Math.sin(t * 2) * 0.2;
                        break;
                }

                // Camera choreography
                const cm = camModes[Math.min(current, camModes.length - 1)];
                const shk = 0.15, sx = Math.sin(t * 5.1) * Math.sin(t * 3.7) * shk, sy = Math.sin(t * 4.3) * Math.cos(t * 2.9) * shk * 0.5;
                const sT = t - sectionStartTime, breathe = Math.sin(t * 0.15) * 1.8;
                let cX, cY, cZ, lkY = cm.ly;
                switch (cm.m) {
                    case 'dolly': { const p = Math.min(1, sT / 16), e = p * p * (3 - 2 * p), r = cm.r - e * 55; cX = Math.sin(t * cm.s) * r; cZ = Math.cos(t * cm.s) * r; cY = cm.h + breathe; break; }
                    case 'orbit': { cX = Math.sin(t * cm.s) * cm.r; cZ = Math.cos(t * cm.s) * cm.r; cY = cm.h + Math.sin(t * cm.s * 0.3) * (cm.tilt || 7) + breathe; break; }
                    case 'track': { cX = Math.sin(t * cm.s) * cm.r + Math.sin(t * 0.1) * 22; cZ = Math.cos(t * cm.s) * cm.r; cY = cm.h + breathe; break; }
                    case 'crane': { const p = Math.min(1, sT / 12), e = p * p * (3 - 2 * p); cX = Math.sin(t * cm.s) * cm.r; cZ = Math.cos(t * cm.s) * cm.r; cY = cm.h - e * 32 + breathe; lkY = cm.ly + e * 9; break; }
                    case 'pushIn': { const p = Math.min(1, sT / 14), e = p * p * (3 - 2 * p), r = cm.r + (1 - e) * 45; cX = Math.sin(t * cm.s) * r; cZ = Math.cos(t * cm.s) * r; cY = cm.h + breathe; break; }
                    case 'drift': { cX = Math.sin(t * cm.s) * cm.r + Math.sin(t * 0.05) * 9; cZ = Math.cos(t * cm.s) * cm.r + Math.cos(t * 0.05) * 9; cY = cm.h + Math.sin(t * 0.08) * 7 + breathe; break; }
                    default: { cX = Math.sin(t * cm.s) * cm.r; cZ = Math.cos(t * cm.s) * cm.r; cY = cm.h + breathe; }
                }
                camera.position.set(cX + sx, cY + sy, cZ);
                camera.lookAt(0, lkY, 0);

                if (cinematicPass) cinematicPass.uniforms.time.value = t;
                const pf = document.getElementById('progressFill');
                if (pf) pf.style.width = isPlaying ? ((narrativeTimer / NARR_DUR) * 100).toFixed(1) + '%' : '0%';

            } catch (e) { console.error('Animate error:', e); }
            if (composer) { try { composer.render(); } catch (e) { renderer.render(scene, camera); } }
            else renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                try { composer.setSize(window.innerWidth, window.innerHeight); } catch (e) { }
            }
            if (cinematicPass && cinematicPass.uniforms) cinematicPass.uniforms.res.value.set(window.innerWidth, window.innerHeight);
        }
        function onKey(e) {
            if (e.key === 'ArrowRight') { if (currentNarrative < sections[current].narratives.length - 1) { currentNarrative++; updateUI(); } else loadSection((current + 1) % sections.length); }
            if (e.key === 'ArrowLeft') { if (currentNarrative > 0) { currentNarrative--; updateUI(); } else loadSection((current - 1 + sections.length) % sections.length); }
            if (e.key === ' ') { e.preventDefault(); isPlaying = !isPlaying; }
        }
        window.loadSection = loadSection;
        try { init(); } catch (e) { console.error('Init failed:', e); document.body.innerHTML = '<div style="color:red;font:20px monospace;padding:40px;">Init error: ' + e.message + '</div>'; }
    </script>
</body>

</html>
